---
title: '【机器学习笔记】：模型性能度量'
date: 2024-04-17
permalink: /posts/2024/04/blog-model-performance-evaluation/
tags:
  - 机器学习
  - 西瓜书
  - 算法
---
<img src='/images/blog/2024-model-performance-evaluation/model-performance-evaluation-1.jpeg'>

*本文主要内容，来自于本人在阅读周志华《机器学习》[1]这本书过程中，总结出来的重要知识点。*

在分类问题中，把分类错误的样本数占样本总数的比例称为“错误率（error rate）”，而分类正确的样本数占样本总数的比例则为“精度（accuracy）”，显然有“精度 + 错误率 = 1”。更一般地，我们把学习器的实际预测输出与样本的真实输出之间的差异称为“误差（error）“，学习器在训练集上的误差称为“训练误差（training error）”或“经验误差（empirical error）“，在新样本上的误差称为“泛化误差（generalization error）”。

我们希望学习器可以从训练样本中学习到适用于所有潜在样本的“普遍规律”，这样在遇到新样本的时候，学习器才能有很好的表现，即我们的目标是减小”泛化误差“。然而，有时候，在训练过程中，学习器把训练样本的所有特征都”记住“了，但是，遇到新样本时，却无法给出正确的判断，这种现象叫做”过拟合（overfitting）“。与”过拟合“相对的是”欠拟合（underfitting）“，即学习器没有从训练样本中总结出”普遍规律“。举个极端一点的例子，两个学生A和B参加考试，A很勤奋，记忆里很好，他把以前所有的考试题目的答案都背了下来，但是A最大的缺点就是脑子比较古板，不懂得变通，题目稍微改一下，他就束手无策了。而B则不同，他很懒，记忆里也不好，考试全靠蒙。想象一下，在一场考试中，如果题目全是从过去的考卷中摘抄来的，那么A肯定可以拿满分，而B靠着蒙，也能得到一些分数；如果所有的题目都是新题目，那么A只能拿0分，B却仍然可以靠蒙，得到一些分数。A同学的学习就是“过拟合”，B同学的学习就是“欠拟合”。

<img src='/images/blog/2024-model-performance-evaluation/model-performance-evaluation-2.webp'>

严格意义上，我们是无法得到学习器的“泛化误差“的，但是可以通过实验对它进行评估。为此，需使用一个“测试集（testing set）”来测试学习器对新样本的判别能力，然后以测试集上的“测试误差（testing error）“作为泛化误差的近似。通常我们假设测试样本也是从样本真实分布中独立同分布采样而得。但需注意的是，测试集应该尽可能与训练集互斥，即测试样本尽量不在训练集中出现、未在训练过程中使用过。

模型评估
======
给定一个数据集$$D = \{(x_1, y_1), (x_2, y_2),...,(x_m, y_m)\}$$。如何将它划分为训练集和测试集，以及如何用他们来训练、评估学习器具呢？下面介绍了几种常用的做法：留出法、交叉验证法、自助法。

留出法
------
“留出法（hold-out）”直接将数据集$$D$$划分为两个互斥的集合，其中一个集合作为训练集$$S$$，另一个作为测试集$$T$$。需注意的是，训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响，例如在分类任务中至少要保持样本的类别比例相似。以最简单的二分类问题为例，假设$$D$$中正例占80%，反例占20%，那么在训练集$$S$$和测试集$$T$$中，正/反例所占百分比也应当保持一致。值得注意的是，即使保持训练集、测试集中各类样本比例一致，仍然会有多种不同的划分方式。一般来说，在使用留出法时，要采用若干次随机划分、重复进行实验评估后取平均值作为留出法的评估结果。例如进行100次随机划分，每次产生一个训练/测试集用于实验评估，100次后就得到100个结果，而留出法返回的则是这100个结果的平均。

交叉验证法
------
“交叉验证法（cross validation）”，又叫“k折交叉验证（k-fold cross validation）”，先将数据集$$D$$划分为k个大小相似的互斥子集， $$D = D_1 \cup D_2 \cup ... \cup D_k$$。每个子集都尽可能保持数据分布的一致性。然后，每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集；这样就可获得k组训练/测试集，从而可进行k次训练和测试，最终返回的是这k个测试结果的均值。 

与留出法相似，将数据集$$D$$划分为k个子集同样存在多种划分方式。为减小因样本划分不同而引入的差别，k折交叉验证通常要随机使用不同的划分重复p次，最终的评估结果是这p次k折交叉验证结果的均值，例如常见的有“10次10折交叉验证”。

<img src='/images/blog/2024-model-performance-evaluation/model-performance-evaluation-3.webp'>

自助法
------
给定包含m个样本的数据集$$D$$，我们对它进行采样产生数据集$$D'$$：每次随机从$$D$$中挑选一个样本，将其拷贝放入$$D'$$，然后再将该样本放回初始数据集$$D$$中，使得该样本在下次采样时仍有可能被采到；这个过程重复执行m次后，我们就得到了包含m个样本的数据集$$D'$$。于是，可以把$$D'$$用作训练集，而$$D-D'$$用作测试集合。这样做的好处是，实际评估的模型与期望评估的模型都使用m个训练样本，不足之处是，$$D$$中有一部分样本会在$$D'$$中多次出现，而另一部分样本不出现，改变了初始数据集的分布。

参数调节
------
大多数机器学习算法都有一些参数需要设定，参数的设置回影响学习器的性能。机器学习通常涉及两类参数：超参数和模型参数。超参数一般由人工设定的，在设定的过程中，往往会对每个参数选择若干个候选值，通过实验来得到最佳的参数组合。而模型参数则是通过对数据的学习来确定的。

性能度量
======
如何评估学习器的性能呢？在预测任务中，要评估学习器的性能需要将学习器预测的结果与真实的标记进行比较。例如，回归任务中常用的均方误差（mean square error）通过如下公式来计算：

$$E(f; D) = \frac{1}{m} \sum^{m}_{i = 1}{(f(x_i) - y_i)}^2$$

下面介绍分类任务中常用的几种性能度量。

错误率与精度
------
错误率是分类错误的样本数占样本总数的比例，而精度则是分类正确的样本数占样本总数的比例。即有：

$$E(f; D) = \frac{1}{m} \sum^{m}_{i = 1}{II(f(x_i) \ne y_i)}$$

$$acc(f; D) = \frac{1}{m} \sum^{m}_{i = 1}{II(f(x_i) = y_i)} = 1 - E(f; D)$$

这里$$II(true) = 1$$， $$II(false) = 0$$。

查全率、查全率与$$F1$$
------
首先介绍混淆矩阵（confusion matrix）。在二分类任务中，通过比较样本数据的真实类别与学习器预测的类别来将其划分为：真正例（TP = true positive）、假正例（FP = false positive）、真反例（TN = true negatove）、假反例（FN = false negative）。

<img src='/images/blog/2024-model-performance-evaluation/model-performance-evaluation-4.webp'>

则定义查准率$$P$$和查全率$$R$$为：
$$P = \frac{TP}{TP + FP}$$， $$R = \frac{TP}{TP + FN}$$

可将查准率理解为预测为正例的样本中，预测正确的样本所占的比例；而将查全率理解为在真实标记为正例的样本中，预测正确的样本所占的比例。查准率和查全率是一对矛盾的度量。一般来说，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。例如，在西瓜分类问题中，若希望将好瓜尽可能多地选出来，则可通过增加选瓜的数量来实现，如果将所有西瓜都选上，那么所有的好瓜也必然都被选上了，但这样查准率就会较低；若希望选出的瓜中好瓜比例尽可能高，则可只挑选最有把握的瓜，但这样就难免会漏掉不少好瓜，使得查全率较低。

对于一组样本，可以根据学习器的预测结果对其进行排序，越靠前的样本是正例的几率越大。按此顺序逐个把样本作为正例进行预测，则每次可以计算出当前的查全率、查准率。以查准率为纵轴、查全率为横轴作图，就得到了查准率-查全率曲线，简称“$$P−R$$曲线”，显示该曲线的图称为“$$P−R$$图”。下图就是一个典型的$$P−R$$图，图中的平衡点是查全率等于查准率的点。在进行比较时，若一个学习器的$$P−R$$曲线被另一个学习器的曲线完全“包住”，则可断言后者的性能优于前者，例如下图中学习器A的性能优于学习器C；如果两个学习器的$$P-R$$曲线发生了交叉，如A与B，则难以一般性地断言两者孰优孰劣，只能在具体的查准率或查全率条件下进行比较。

<img src='/images/blog/2024-model-performance-evaluation/model-performance-evaluation-5.webp'>

$$F1$$参数综合考量了查准率和查全率，它是二者的调和平均值，定义如下：
$$F1 = \frac{2 \times P \times R}{P + R} = \frac{2 \times TP }{ 样例总数 + TP - TN}$$

一般地，$$F1$$越大，则学习器的性能越好。

$$ROC$$与$$AUC$$
------
$$ROC$$（Receiver Operating Characteristic）曲线的生成与$$P−R$$曲线类似，先根据学习器的预测结果对样本进行排序，按此顺序逐个把样本作为正例进行预测，每次计算出真正例率（ True Positive Rate，TPR）和假正例率（ False Positive Rate，FPR），并分别以它们作为纵坐标、横坐标得到一系列的点，把这些点依次相连便得到了$$ROC$$曲线。 显示$$ROC$$曲线的图即为$$ROC$$图。TPR和FPR的计算公式如下：

$$TPR = \frac{TP}{TP + FN}$$

$$FPR = \frac{FP}{TN + FP}$$

若有足够多的样本，$$ROC$$曲线应当是平滑的，而对于有限样本，$$ROC$$曲线的是由一系列横纵线段连接而成的。对于一个样本集，它包含$$m^+$$个正例和$$m^-$$个反例，根据学习器预测结果对样例进行排序，然后把分类阈值设为最大，即把所有样例均预测为反例，此时真正例率和假正例率均为0，在坐标$$(0,0)$$处标记一个点。然后，将分类阈值依次设为每个样例的预测值，即依次将每个样例划分为正例。设前一个标记点坐标为$$(X,Y)$$，当前若为真正例，则对应标记点的坐标为$$(x, y + \frac{1}{m^+})$$，当前若为假正例，则对应标记点的坐标为$$(x + \frac{1}{m^-}, y )$$，然后用线段连接相邻点即得。下图显示了两个$$ROC$$曲线，分别对应无穷样本和有限样本的情形。

<img src='/images/blog/2024-model-performance-evaluation/model-performance-evaluation-6.webp'>

有了$$ROC$$曲线，如何用它来衡量学习器的性能呢？$$ROC$$曲线覆盖的面积，即$$AUC$$（Area Under ROC Curve）就是一个很好的度量。对于由有限样本生成的$$ROC$$曲线，$$AUC$$的计算公式如下：
$$AUC = \frac{1}{2}\sum_{i=1}^{m-1}{(x_{i+1} - x_i)(y_i + y_{i+1})}$$

代价敏感错误率与代价曲线
------
在现实任务中常会遇到这样的情况：不同类型的错误所造成的后果不同。例如在医疗诊断中，错误地把患者诊断为健康人与错误地把健康人诊断为患者，看起来都是犯了“一次错误”，但后者的影响是增加了进一步检查的麻烦，前者的后果却可能是丧失了拯救生命的最佳时机；再如，门禁系统错误地把可通行人员拦在门外，将使得用户体验不佳，但错误地把陌生人放进门内，则会造成严重的安全事故。为权衡不同类型错误所造成的不同损失，可为错误赋予“非均等代价”(unequal cost)。以二分类任务为例，我们可以设定一个“代价矩阵”(cost matrix)，如下图所示，其中$$cost_{ij}$$表示将第$$i$$类样本预测为第$$j$$类样本的代价。

<img src='/images/blog/2024-model-performance-evaluation/model-performance-evaluation-7.webp'>

于是，学习的目标就变成最小化总体代价。对于二分类问题，假设第0类为正类别，第1类作为反类，令$$D^+$$与$$D^-$$分别代表样本集 $$D$$中正例子集与反类子集，则代价敏感（cost-sensitive）错误率为：
$$E(f;D;cost) = \frac{1}{m}(\sum_{x_i\in D^+}{II(f(x_i) \ne y_i)\times cost_{01}} + \sum_{x_i\in D^-}{II(f(x_i) \ne y_i)\times cost_{10}})$$

在非均等代价下，我们不能直接用$$ROC$$曲线来判断学习器的性能，而要用代价曲线（cost curve）。代价曲线的横轴为正例概率代价：
$$P(+)cost = \frac{p \times cost_{01}}{p \times cost_{01} + (1-p)\times cost_{10}}$$

这里$$p$$是正例样本所占的比率，纵轴是归一化代价：
$$cost_{norm} = \frac{FNR \times p \times cost_{01} + FPR \times (1-p)\times cost_{10}}{p \times cost_{01} + (1-p)\times cost_{10}} = FNR \times P(+)cost + FPR \times (1 - P(+)cost)$$

期中FPR是前面定义过的假正例率，而$$FNR = 1 - TPR$$，是假反例率。

代价曲线的绘制很简单：$$ROC$$曲线上每一点对应了代价平面上的一条线段，设$$ROC$$曲线上点的坐标为$$（FPR， TPR）$$，则可相应计算出FNR，然后在代价平面上绘制一条从$$（0， FPR）$$到$$（1，FNR）$$的线段，线段下的面积即表示了该条件下的期望总体代价；如此将$$ROC$$曲线上的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价。

<img src='/images/blog/2024-model-performance-evaluation/model-performance-evaluation-8.webp'>